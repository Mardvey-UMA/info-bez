<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# –ü–æ–ª–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Å–∫—Ä–∏–ø—Ç—É Disk Auditor –Ω–∞ Scala

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ

1. [–û–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞](#%D0%BE%D0%B1%D1%89%D0%B5%D0%B5-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0)
2. [–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö](#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
3. [–ê–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤](#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2)
4. [–ê–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ö–æ–¥–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π](#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B9)
5. [–ê–ª–≥–æ—Ä–∏—Ç–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π](#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%BE%D1%82%D1%81%D0%BB%D0%B5%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9)
6. [–ê–ª–≥–æ—Ä–∏—Ç–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π](#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9)
7. [–ì–µ–Ω–µ—Ä–∞—Ü–∏—è HTML-–æ—Ç—á–µ—Ç–æ–≤](#%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-html-%D0%BE%D1%82%D1%87%D0%B5%D1%82%D0%BE%D0%B2)
8. [–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ Scala](#%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-scala)

***

## –û–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞

**Disk Auditor** ‚Äî —ç—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –Ω–∞ —á–∏—Å—Ç–æ–π Scala –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫. –ü—Ä–æ–≥—Ä–∞–º–º–∞ —Å–∫–∞–Ω–∏—Ä—É–µ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é, –≤—ã—á–∏—Å–ª—è–µ—Ç —Ö–µ—à–∏ —Ñ–∞–π–ª–æ–≤ –∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–∞–º–∏.[^1][^5]

### –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:

- –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ö–µ—à-—Å—É–º–º —Ñ–∞–π–ª–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º XOR-–∞–ª–≥–æ—Ä–∏—Ç–º–∞
- –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö, –∏–∑–º–µ–Ω–µ–Ω–Ω—ã—Ö, —É–¥–∞–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
- –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –ø–æ —Ö–µ—à—É
- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è HTML –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –æ—Ç—á–µ—Ç–æ–≤ —Å –¥—Ä–µ–≤–æ–≤–∏–¥–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
- –•—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤ JSON-—Ñ–æ—Ä–º–∞—Ç–µ

***

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö

### Sealed trait FileState

```scala
sealed trait FileState
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ë–∞–∑–æ–≤—ã–π sealed trait –¥–ª—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π —Ñ–∞–π–ª–∞.[^2][^1]

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Scala**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `sealed trait` –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—Å–µ –Ω–∞—Å–ª–µ–¥–Ω–∏–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Ç–æ–º –∂–µ —Ñ–∞–π–ª–µ. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –ø—Ä–æ–≤–µ—Ä—è—Ç—å exhaustive pattern matching (–ø–æ–ª–Ω–æ—Ç—É —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å –æ–±—Ä–∞–∑—Ü–æ–º). –ï—Å–ª–∏ –≤—ã –∑–∞–±—É–¥–µ—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ–¥–∏–Ω –∏–∑ —Å–ª—É—á–∞–µ–≤ –≤ `match`, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–¥–∞—Å—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ.

### Case –∫–ª–∞—Å—Å—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π

```scala
case class Unchanged(path: String, hash: Int) extends FileState
case class Modified(path: String, oldHash: Int, newHash: Int) extends FileState
case class Deleted(path: String, oldHash: Int) extends FileState
case class Added(path: String, newHash: Int) extends FileState
case class Renamed(oldPath: String, newPath: String, hash: Int) extends FileState
case class ErrorFile(path: String, error: String) extends FileState
case class EmptyFile(path: String) extends FileState
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ö–∞–∂–¥—ã–π case class –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ–∞–π–ª–∞.

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ Scala**:

- `case class` –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º–µ—Ç–æ–¥—ã `equals`, `hashCode`, `toString`, `copy` –∏ `apply`[^9]
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –ø–∞—Ç—Ç–µ—Ä–Ω Value Object (–Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–π –æ–±—ä–µ–∫—Ç)
- –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ pattern matching –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–∞–∫—Ç–æ—Ä–æ–≤
- `copy` –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–ø–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤

**–°–æ—Å—Ç–æ—è–Ω–∏—è**:

- `Unchanged`: —Ñ–∞–π–ª –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è
- `Modified`: —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å (—Ä–∞–∑–Ω—ã–µ —Ö–µ—à–∏)
- `Deleted`: —Ñ–∞–π–ª –±—ã–ª —É–¥–∞–ª–µ–Ω
- `Added`: –Ω–æ–≤—ã–π —Ñ–∞–π–ª –ø–æ—è–≤–∏–ª—Å—è
- `Renamed`: —Ñ–∞–π–ª –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω (—Ç–æ—Ç –∂–µ —Ö–µ—à, –¥—Ä—É–≥–æ–π –ø—É—Ç—å)
- `ErrorFile`: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ
- `EmptyFile`: –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª (0 –±–∞–π—Ç)


### FileInfo

```scala
case class FileInfo(
  path: String,
  hash: Int,
  size: Long,
  lastModified: String
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∞–π–ª–µ –≤ JSON-–±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.

**–ü–æ–ª—è**:

- `path`: –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
- `hash`: 32-–±–∏—Ç–Ω–æ–µ —Ö–µ—à-–∑–Ω–∞—á–µ–Ω–∏–µ (Int –≤ Scala = 4 –±–∞–π—Ç–∞)
- `size`: —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö (Long = 8 –±–∞–π—Ç, –¥–æ 9 —ç–∫–∑–∞–±–∞–π—Ç)
- `lastModified`: –≤—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Å—Ç—Ä–æ–∫–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ

***

## –ê–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤

### BitStreamProcessor

```scala
class BitStreamProcessor(val buffer: ByteBuffer) extends AnyVal {
  def processXor: Int = {
    var result = 0
    while (buffer.remaining() >= 2) {
      result ^= buffer.getShort() & 0xFFFF
    }
    if (buffer.hasRemaining) {
      val lastByte = buffer.get() & 0xFF
      result ^= (lastByte << 8)
    }
    result
  }
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –û–±—Ä–∞–±–æ—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞ –±–∞–π—Ç–æ–≤ –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ XOR-—Ö–µ—à–∞.[^1][^2]

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Scala**:

- `extends AnyVal` ‚Äî —ç—Ç–æ value class, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ —Å–æ–∑–¥–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤ runtime. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –µ–≥–æ, –∏–∑–±–µ–≥–∞—è heap allocation[^4]
- Value classes –≤ Scala –ø–æ–∑–≤–æ–ª—è—é—Ç –¥–æ–±–∞–≤–ª—è—Ç—å –º–µ—Ç–æ–¥—ã –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º —Ç–∏–ø–∞–º –±–µ–∑ overhead

**–ê–ª–≥–æ—Ä–∏—Ç–º –ø–æ—Å—Ç—Ä–æ—á–Ω–æ**:

```scala
var result = 0
```

–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω—É–ª–µ–º. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `var`, —Ç–∞–∫ –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å—Å—è (–≤ Scala `var` = mutable, `val` = immutable).

```scala
while (buffer.remaining() >= 2) {
  result ^= buffer.getShort() & 0xFFFF
}
```

**–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç**:

1. `buffer.remaining()` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –±–∞–π—Ç –¥–ª—è —á—Ç–µ–Ω–∏—è
2. –ü–æ–∫–∞ –µ—Å—Ç—å –º–∏–Ω–∏–º—É–º 2 –±–∞–π—Ç–∞, —á–∏—Ç–∞–µ–º `Short` (16-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ)
3. `buffer.getShort()` —á–∏—Ç–∞–µ—Ç 2 –±–∞–π—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Short (-32768 –¥–æ 32767)
4. `& 0xFFFF` –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç signed Short –≤ unsigned (0 –¥–æ 65535) —á–µ—Ä–µ–∑ –±–∏—Ç–æ–≤—É—é –º–∞—Å–∫—É
5. `^=` ‚Äî XOR assignment: `result = result ^ value`

**–ü–æ—á–µ–º—É XOR**: XOR –æ–ø–µ—Ä–∞—Ü–∏—è –æ–±–ª–∞–¥–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–∞–º–∏:

- –ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å: `a ^ b = b ^ a`
- –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å: `(a ^ b) ^ c = a ^ (b ^ c)`
- –õ—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ XOR —Å —Å–∞–º–∏–º —Å–æ–±–æ–π –¥–∞–µ—Ç 0: `a ^ a = 0`
- XOR —Å 0 –Ω–µ –º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ: `a ^ 0 = a`

```scala
if (buffer.hasRemaining) {
  val lastByte = buffer.get() & 0xFF
  result ^= (lastByte << 8)
}
```

**–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –±–∞–π—Ç–∞**:

1. –ï—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è 1 –±–∞–π—Ç (–Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ)
2. –ß–∏—Ç–∞–µ–º –µ–≥–æ –∏ –º–∞—Å–∫–∏—Ä—É–µ–º –∫–∞–∫ unsigned: `& 0xFF` (0-255)
3. –°–¥–≤–∏–≥–∞–µ–º –≤–ª–µ–≤–æ –Ω–∞ 8 –±–∏—Ç: `<< 8` (—É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ 256)
4. XOR —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º

**–ü—Ä–∏–º–µ—Ä**: –±–∞–π—Ç `0x5A` —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è `0x5A00` –∏ XOR'–∏—Ç—Å—è —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º.

### calculateHash

```scala
def calculateHash(file: Path): FileOperation[Int] = {
  Try {
    if (Files.isDirectory(file)) {
      FileError("–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥")
    } else if (!Files.exists(file) || !Files.isReadable(file)) {
      FileError(s"–§–∞–π–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: $file")
    } else {
      val size = Files.size(file)
      if (size == 0) {
        FileSuccess(0)
      } else {
        val channel = FileChannel.open(file, StandardOpenOption.READ)
        try {
          val buffer = ByteBuffer.allocate(math.min(size.toInt, 1024 * 1024))
          var hash = 0

          while (channel.read(buffer) != -1) {
            buffer.flip()
            val processor = new BitStreamProcessor(buffer)
            hash ^= processor.processXor
            buffer.clear()
          }

          FileSuccess(hash)
        } finally {
          channel.close()
        }
      }
    }
  } match {
    case Success(result) => result
    case Failure(e) => FileError(s"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: ${e.getMessage}")
  }
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ö–µ—à–∞ —Ñ–∞–π–ª–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫.[^4][^1]

**–ü–æ—Å—Ç—Ä–æ—á–Ω—ã–π —Ä–∞–∑–±–æ—Ä**:

```scala
def calculateHash(file: Path): FileOperation[Int] = {
```

–§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç `Path` (–∏–∑ Java NIO) –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `FileOperation[Int]` ‚Äî —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.

```scala
Try {
```

`Try` –∏–∑ `scala.util` ‚Äî –º–æ–Ω–∞–¥–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–∫–ª—é—á–µ–Ω–∏–π. –û–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—Ä–æ—Å–∏—Ç—å exception, –≤ `Success` –∏–ª–∏ `Failure`[^2].

```scala
if (Files.isDirectory(file)) {
  FileError("–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥")
```

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ path –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–µ–π. –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É "–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥" –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ø–∞–ø–∫—É –∫–∞–∫ —Ñ–∞–π–ª.

```scala
} else if (!Files.exists(file) || !Files.isReadable(file)) {
  FileError(s"–§–∞–π–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: $file")
```

–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∏ –ø—Ä–∞–≤ –Ω–∞ —á—Ç–µ–Ω–∏–µ. `s"..."` ‚Äî string interpolation –≤ Scala, `$file` –≤—Å—Ç–∞–≤–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.

```scala
val size = Files.size(file)
if (size == 0) {
  FileSuccess(0)
```

–ü—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ø–æ–ª—É—á–∞—é—Ç —Ö–µ—à = 0 –±–µ–∑ —á—Ç–µ–Ω–∏—è. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è I/O –æ–ø–µ—Ä–∞—Ü–∏–π.

```scala
val channel = FileChannel.open(file, StandardOpenOption.READ)
```

`FileChannel` ‚Äî Java NIO –∫–ª–∞—Å—Å –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤. –ë—ã—Å—Ç—Ä–µ–µ, —á–µ–º `FileInputStream`, —Ç–∞–∫ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç direct buffer –∏ –º–µ–Ω—å—à–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤[^4].

```scala
val buffer = ByteBuffer.allocate(math.min(size.toInt, 1024 * 1024))
```

**–ë—É—Ñ–µ—Ä –¥–ª—è —á—Ç–µ–Ω–∏—è**:

- `ByteBuffer` ‚Äî Java NIO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–π—Ç–∞–º–∏
- –†–∞–∑–º–µ—Ä: –º–∏–Ω–∏–º—É–º –∏–∑ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ –∏–ª–∏ 1MB (1048576 –±–∞–π—Ç)
- `math.min` –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç OutOfMemoryError –ø—Ä–∏ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–∞—Ö
- –î–ª—è —Ñ–∞–π–ª–∞ 500KB –±—É—Ñ–µ—Ä = 500KB, –¥–ª—è 5MB –±—É—Ñ–µ—Ä = 1MB

```scala
var hash = 0
```

–ê–∫–∫—É–º—É–ª—è—Ç–æ—Ä –¥–ª—è —Ö–µ—à–∞. –ò—Å–ø–æ–ª—å–∑—É–µ–º `var`, —Ç–∞–∫ –∫–∞–∫ –±—É–¥–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å –≤ —Ü–∏–∫–ª–µ.

```scala
while (channel.read(buffer) != -1) {
```

**–¶–∏–∫–ª —á—Ç–µ–Ω–∏—è**:

- `channel.read(buffer)` —á–∏—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ –≤ –±—É—Ñ–µ—Ä
- –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö –±–∞–π—Ç –∏–ª–∏ -1 –ø—Ä–∏ EOF (End of File)
- –ë—É—Ñ–µ—Ä –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ

```scala
buffer.flip()
```

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥**! `flip()` –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –±—É—Ñ–µ—Ä –∏–∑ —Ä–µ–∂–∏–º–∞ –∑–∞–ø–∏—Å–∏ –≤ —Ä–µ–∂–∏–º —á—Ç–µ–Ω–∏—è:

- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç `limit = position` (—Å–∫–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–∞–ª–∏)
- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç `position = 0` (–Ω–∞—á–∞–ª–æ –¥–ª—è —á—Ç–µ–Ω–∏—è)
- –ë–µ–∑ `flip()` `remaining()` –≤–µ—Ä–Ω–µ—Ç 0, –∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–æ—á–∏—Ç–∞—é—Ç—Å—è

```scala
val processor = new BitStreamProcessor(buffer)
hash ^= processor.processXor
```

–°–æ–∑–¥–∞–µ–º value class –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –∏ XOR'–∏–º –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç–µ–∫—É—â–∏–º —Ö–µ—à–µ–º. –ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ñ–∞–π–ª–∞ –≤–Ω–æ—Å–∏—Ç –≤–∫–ª–∞–¥ –≤ –∏—Ç–æ–≥–æ–≤—ã–π —Ö–µ—à.[^1]

```scala
buffer.clear()
```

`clear()` –≥–æ—Ç–æ–≤–∏—Ç –±—É—Ñ–µ—Ä –∫ —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–ø–∏—Å–∏:

- `position = 0`
- `limit = capacity`
- –î–∞–Ω–Ω—ã–µ –ù–ï —É–¥–∞–ª—è—é—Ç—Å—è, –ø—Ä–æ—Å—Ç–æ —Å–±—Ä–∞—Å—ã–≤–∞—é—Ç—Å—è —É–∫–∞–∑–∞—Ç–µ–ª–∏

```scala
} finally {
  channel.close()
}
```

`finally` –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –∑–∞–∫—Ä—ã—Ç–∏–µ channel –¥–∞–∂–µ –ø—Ä–∏ exception. –í–∞–∂–Ω–æ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤—ã—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–æ–≤.

```scala
} match {
  case Success(result) => result
  case Failure(e) => FileError(s"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: ${e.getMessage}")
}
```

Pattern matching –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ `Try`. –ò–∑–≤–ª–µ–∫–∞–µ–º `FileOperation` –∏–∑ `Success` –∏–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º exception –≤ `FileError`.[^2]

**–ü–æ—á–µ–º—É XOR –≤–º–µ—Å—Ç–æ SHA-256**:

- XOR —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ 10-100 —Ä–∞–∑ –±—ã—Å—Ç—Ä–µ–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö —Ö–µ—à–µ–π[^2][^4]
- –î–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ñ–∞–π–ª–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —Ö–µ—à–∞
- –ù–µ –Ω—É–∂–Ω–∞ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è —Å—Ç–æ–π–∫–æ—Å—Ç—å (–Ω–µ –∑–∞—â–∏—â–∞–µ–º –æ—Ç –∞—Ç–∞–∫)
- –ú–µ–Ω—å—à–µ –Ω–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ CPU –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç—ã—Å—è—á —Ñ–∞–π–ª–æ–≤

***

## –ê–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ö–æ–¥–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π

### walkDirectory

```scala
def walkDirectory(root: Path): List[Path] = {
  println(s"üìÇ –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ö–æ–¥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: $root")

  if (!Files.exists(root)) {
    println(s"‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: $root")
    return List.empty
  }

  if (!Files.isDirectory(root)) {
    println(s"‚ùå –£–∫–∞–∑–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–µ–π: $root")
    return List.empty
  }

  def walkRecursive(dir: Path, depth: Int = 0): List[Path] = {
    val indent = "  " * depth
    println(s"$indentüîç –°–∫–∞–Ω–∏—Ä—É–µ–º: ${dir.getFileName}")

    try {
      import scala.jdk.CollectionConverters._
      val entries = Files.list(dir).iterator().asScala.toList

      entries.flatMap { path =>
        val fileName = path.getFileName.toString

        if (Files.isDirectory(path)) {
          if (fileName != OUTPUT_DIR_NAME && !Files.isSymbolicLink(path)) {
            walkRecursive(path, depth + 1)
          } else if (fileName == OUTPUT_DIR_NAME) {
            println(s"$indent‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –æ—Ç—á–µ—Ç–æ–≤: $fileName")
            List.empty
          } else {
            println(s"$indent‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫—É—é —Å—Å—ã–ª–∫—É: $fileName")
            List.empty
          }
        } else {
          println(s"$indentüìÑ –ù–∞–π–¥–µ–Ω —Ñ–∞–π–ª: $fileName")
          List(path)
        }
      }
    } catch {
      case e: AccessDeniedException =>
        println(s"$indent‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: ${dir.getFileName} - ${e.getMessage}")
        List.empty
      case e: Exception =>
        println(s"$indent‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ö–æ–¥–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: ${dir.getFileName} - ${e.getMessage}")
        List.empty
    }
  }

  val files = walkRecursive(root)
  println(s"‚úÖ –û–±—Ö–æ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω. –ù–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: ${files.size}")
  files
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –¥–µ—Ä–µ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π —Å –ø—Ä–æ–ø—É—Å–∫–æ–º —Å–ª—É–∂–µ–±–Ω—ã—Ö –ø–∞–ø–æ–∫.

**–ê–ª–≥–æ—Ä–∏—Ç–º –¥–µ—Ç–∞–ª—å–Ω–æ**:

### –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

```scala
if (!Files.exists(root)) {
  println(s"‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: $root")
  return List.empty
}

if (!Files.isDirectory(root)) {
  println(s"‚ùå –£–∫–∞–∑–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–µ–π: $root")
  return List.empty
}
```

**Early return pattern**: –ë—ã—Å—Ç—Ä—ã–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –í Scala `return` —Ä–µ–¥–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (–ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—é—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏—è), –Ω–æ –∑–¥–µ—Å—å –æ–ø—Ä–∞–≤–¥–∞–Ω –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏.

### –í–ª–æ–∂–µ–Ω–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è

```scala
def walkRecursive(dir: Path, depth: Int = 0): List[Path] = {
```

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Scala**: –í–ª–æ–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (nested functions) –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º –≤–Ω–µ—à–Ω–µ–π —Ñ—É–Ω–∫—Ü–∏–∏. `depth = 0` ‚Äî default parameter (–ø–∞—Ä–∞–º–µ—Ç—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).

```scala
val indent = "  " * depth
```

**String multiplication**: –í Scala —Å—Ç—Ä–æ–∫–∏ –º–æ–∂–Ω–æ —É–º–Ω–æ–∂–∞—Ç—å. `"  " * 3 = "      "`. –°–æ–∑–¥–∞–µ—Ç –æ—Ç—Å—Ç—É–ø—ã –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –≥–ª—É–±–∏–Ω—ã –¥–µ—Ä–µ–≤–∞.

```scala
import scala.jdk.CollectionConverters._
val entries = Files.list(dir).iterator().asScala.toList
```

**Java interop**:

- `Files.list(dir)` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Java `Stream<Path>`
- `.iterator()` –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç Stream –≤ Iterator
- `.asScala` (–∏–∑ CollectionConverters) –æ–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç Java Iterator –≤ Scala Iterator
- `.toList` –º–∞—Ç–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ Scala List

**–ü–æ—á–µ–º—É –Ω–µ stream –Ω–∞–ø—Ä—è–º—É—é**: Java Stream –Ω–µ –∏–º–µ–µ—Ç –ø—Ä—è–º–æ–≥–æ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–∞ –≤ Scala, —á–µ—Ä–µ–∑ Iterator –∫–æ–Ω–≤–µ—Ä—Å–∏—è –±–æ–ª–µ–µ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–∞.

```scala
entries.flatMap { path =>
```

**`flatMap`** ‚Äî –∫–ª—é—á–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è:

- –ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É
- –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–ª–µ–∫—Ü–∏—é (List)
- –í—Å–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "—Ä–∞—Å–ø–ª—é—â–∏–≤–∞—é—Ç—Å—è" –≤ –æ–¥–Ω—É
- –ü—Ä–∏–º–µ—Ä: `List(1,2,3).flatMap(x => List(x, x*10)) = List(1,10,2,20,3,30)`

–í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ:

- –î–ª—è —Ñ–∞–π–ª–æ–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `List(path)` (—Å–ø–∏—Å–æ–∫ –∏–∑ –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞)
- –î–ª—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–µ–∫—É—Ä—Å–∏–∏ (—Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –≤ –ø–æ–¥–¥–µ—Ä–µ–≤–µ)
- –î–ª—è –ø—Ä–æ–ø—É—Å–∫–∞–µ–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `List.empty`
- `flatMap` –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –≤—Å–µ —ç—Ç–æ –≤ –æ–¥–∏–Ω –ø–ª–æ—Å–∫–∏–π —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤


### –õ–æ–≥–∏–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏

```scala
if (Files.isDirectory(path)) {
  if (fileName != OUTPUT_DIR_NAME && !Files.isSymbolicLink(path)) {
    walkRecursive(path, depth + 1)
```

**–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Å–ø—É—Å–∫**:

- –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç ‚Äî –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
- –ò —ç—Ç–æ –ù–ï `disk_auditor_reports` (–Ω–∞—à–∞ —Å–ª—É–∂–µ–±–Ω–∞—è –ø–∞–ø–∫–∞)
- –ò —ç—Ç–æ –ù–ï —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è —Å—Å—ã–ª–∫–∞ (–≤–æ –∏–∑–±–µ–∂–∞–Ω–∏–µ —Ü–∏–∫–ª–æ–≤)
- –¢–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –µ—ë —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω–æ–π –≥–ª—É–±–∏–Ω–æ–π

```scala
} else if (fileName == OUTPUT_DIR_NAME) {
  println(s"$indent‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –æ—Ç—á–µ—Ç–æ–≤: $fileName")
  List.empty
```

–Ø–≤–Ω–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å –æ—Ç—á–µ—Ç–∞–º–∏, –≤–æ–∑–≤—Ä–∞—â–∞—è –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫.

```scala
} else {
  println(s"$indent‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫—É—é —Å—Å—ã–ª–∫—É: $fileName")
  List.empty
}
```

–°–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏–µ —Å—Å—ã–ª–∫–∏ –æ–ø–∞—Å–Ω—ã ‚Äî –º–æ–≥—É—Ç —Å–æ–∑–¥–∞—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω—É—é —Ä–µ–∫—É—Ä—Å–∏—é.

```scala
} else {
  println(s"$indentüìÑ –ù–∞–π–¥–µ–Ω —Ñ–∞–π–ª: $fileName")
  List(path)
}
```

–§–∞–π–ª ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∫ `List(path)`.

### –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

```scala
} catch {
  case e: AccessDeniedException =>
    println(s"$indent‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: ${dir.getFileName} - ${e.getMessage}")
    List.empty
  case e: Exception =>
    println(s"$indent‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ö–æ–¥–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: ${dir.getFileName} - ${e.getMessage}")
    List.empty
}
```

**Pattern matching –¥–ª—è exceptions**:

- –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è `AccessDeniedException` (–Ω–µ—Ç –ø—Ä–∞–≤)
- –û–±—â–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
- –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ö–æ–¥ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö

**–ü–æ—á–µ–º—É List.empty**: –í Scala –Ω–µ—Ç `null`, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è "–æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –¥–∞–Ω–Ω—ã—Ö".

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã

–î–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:

```
root/
‚îú‚îÄ‚îÄ file1.txt
‚îú‚îÄ‚îÄ subdir1/
‚îÇ   ‚îú‚îÄ‚îÄ file2.txt
‚îÇ   ‚îî‚îÄ‚îÄ subdir2/
‚îÇ       ‚îî‚îÄ‚îÄ file3.txt
‚îî‚îÄ‚îÄ disk_auditor_reports/ (–ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è)
```

–ê–ª–≥–æ—Ä–∏—Ç–º:

1. `walkRecursive(root, 0)` ‚Üí `List(root/file1.txt) ++ walkRecursive(subdir1, 1) ++ List.empty`
2. `walkRecursive(subdir1, 1)` ‚Üí `List(subdir1/file2.txt) ++ walkRecursive(subdir2, 2)`
3. `walkRecursive(subdir2, 2)` ‚Üí `List(subdir2/file3.txt)`
4. –ò—Ç–æ–≥: `List(root/file1.txt, subdir1/file2.txt, subdir2/file3.txt)`

***

## –ê–ª–≥–æ—Ä–∏—Ç–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π

### scanFiles

```scala
def scanFiles(root: Path): Map[String, FileInfo] = {
  val resultMap = TrieMap[String, FileInfo]()
  val errorList = TrieMap[String, String]()
  val emptyFiles = TrieMap[String, Unit]()

  println("üöÄ –ù–∞—á–∏–Ω–∞–µ–º —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤...")
  val files = walkDirectory(root)

  if (files.isEmpty) {
    println("‚ö†Ô∏è –§–∞–π–ª–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
    return Map.empty
  }

  val totalFilesCount = files.size
  println(s"üìä –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: $totalFilesCount")

  files.zipWithIndex.foreach { case (file, index) =>
    val relativePath = root.relativize(file).toString.replace('\\', '/')

    calculateHash(file) match {
      case FileSuccess(hash) =>
        val size = Files.size(file)
        val lastModified = Files.getLastModifiedTime(file).toString

        if (size == 0) {
          emptyFiles += (relativePath -> ())
        }

        resultMap += (relativePath -> FileInfo(relativePath, hash, size, lastModified))

        val processed = index + 1
        if (processed % 10 == 0 || processed == totalFilesCount) {
          val progress = (processed * 100) / totalFilesCount
          println(s"üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: $processed/$totalFilesCount ($progress%)")
        }

      case FileError(msg) =>
        if (msg != "–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥") {
          errorList += (relativePath -> msg)
        }
        val processed = index + 1
        if (processed % 10 == 0 || processed == totalFilesCount) {
          val progress = (processed * 100) / totalFilesCount
          println(s"üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: $processed/$totalFilesCount ($progress%)")
        }
    }
  }

  println(s"üèÅ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${resultMap.size}")

  if (errorList.nonEmpty) {
    println(s"\n‚ö†Ô∏è –û—à–∏–±–∫–∏ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–æ–≤ (${errorList.size}):")
    errorList.take(10).foreach { case (path, error) =>
      println(s"  - $path: $error")
    }
    if (errorList.size > 10) {
      println(s"  ... –∏ –µ—â–µ ${errorList.size - 10} –æ—à–∏–±–æ–∫")
    }
  }

  if (emptyFiles.nonEmpty) {
    println(s"\n‚óã –ù–∞–π–¥–µ–Ω–æ –ø—É—Å—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤: ${emptyFiles.size}")
    emptyFiles.keys.take(5).foreach(path => println(s"  - $path"))
    if (emptyFiles.size > 5) {
      println(s"  ... –∏ –µ—â–µ ${emptyFiles.size - 5} –ø—É—Å—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤")
    }
  }

  resultMap.toMap
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ snapshot —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è.

**–î–µ—Ç–∞–ª—å–Ω—ã–π —Ä–∞–∑–±–æ—Ä**:

### Concurrent –∫–æ–ª–ª–µ–∫—Ü–∏–∏

```scala
val resultMap = TrieMap[String, FileInfo]()
val errorList = TrieMap[String, String]()
val emptyFiles = TrieMap[String, Unit]()
```

**`TrieMap`** ‚Äî thread-safe hash map –∏–∑ Scala concurrent collections:

- –ù–µ —Ç—Ä–µ–±—É–µ—Ç —è–≤–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
- –û—Å–Ω–æ–≤–∞–Ω –Ω–∞ lock-free –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö (–±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫)
- –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
- –í –¥–∞–Ω–Ω–æ–º –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –≥–æ—Ç–æ–≤ –∫ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–∞—Ü–∏–∏

**–ü–æ—á–µ–º—É Unit**: `Map[String, Unit]` —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ `Set[String]`, –Ω–æ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Ö—Ä–∞–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –±—É–¥—É—â–µ–º.

### –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤

```scala
files.zipWithIndex.foreach { case (file, index) =>
```

**`zipWithIndex`**:

- –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç `List[Path]` –≤ `List[(Path, Int)]`
- –ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç –∏–Ω–¥–µ–∫—Å: `(element, 0), (element, 1), ...`
- –ü–æ–∑–≤–æ–ª—è–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å

```scala
val relativePath = root.relativize(file).toString.replace('\\', '/')
```

**–û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å**:

- `root.relativize(file)` —É–±–∏—Ä–∞–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ—Ä–Ω–µ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
- `/home/user/project/file.txt` ‚Üí `file.txt`
- `/home/user/project/dir/file.txt` ‚Üí `dir/file.txt`
- `.replace('\\', '/')` –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ –¥–ª—è Windows

**–ó–∞—á–µ–º**: –•—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—É—Ç–µ–π –¥–µ–ª–∞–µ—Ç –±–∞–∑—É –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ–π –º–µ–∂–¥—É —Å–∏—Å—Ç–µ–º–∞–º–∏.

### Pattern matching —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

```scala
calculateHash(file) match {
  case FileSuccess(hash) =>
```

–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ö–µ—à–∞.

```scala
val size = Files.size(file)
val lastModified = Files.getLastModifiedTime(file).toString
```

–°–æ–±–∏—Ä–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª–∞. `lastModified` –≤ —Ñ–æ—Ä–º–∞—Ç–µ ISO-8601: `2025-09-30T22:45:00Z`.

```scala
if (size == 0) {
  emptyFiles += (relativePath -> ())
}
```

–û—Ç–º–µ—á–∞–µ–º –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.

```scala
resultMap += (relativePath -> FileInfo(relativePath, hash, size, lastModified))
```

**–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ Map**: `+=` —ç—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π —Å–∞—Ö–∞—Ä –¥–ª—è `resultMap.put(key, value)`.

### –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä

```scala
val processed = index + 1
if (processed % 10 == 0 || processed == totalFilesCount) {
  val progress = (processed * 100) / totalFilesCount
  println(s"üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: $processed/$totalFilesCount ($progress%)")
}
```

**–õ–æ–≥–∏–∫–∞**:

- –í—ã–≤–æ–¥–∏–º –∫–∞–∂–¥—ã–µ 10 —Ñ–∞–π–ª–æ–≤: `processed % 10 == 0`
- –ò–ª–∏ –≤ –∫–æ–Ω—Ü–µ: `processed == totalFilesCount`
- –ü—Ä–æ—Ü–µ–Ω—Ç: `(10 * 100) / 100 = 10%`


### –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

```scala
case FileError(msg) =>
  if (msg != "–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥") {
    errorList += (relativePath -> msg)
  }
```

**–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –æ—à–∏–±–æ–∫**: –û—à–∏–±–∫–∞ "–≠—Ç–æ –∫–∞—Ç–∞–ª–æ–≥" –Ω–µ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ —Å–ø–∏—Å–æ–∫, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è (–º—ã —É–∂–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –≤ `walkDirectory`, –Ω–æ double-check –Ω–µ –ø–æ–º–µ—à–∞–µ—Ç).

### –í—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏

```scala
if (errorList.nonEmpty) {
  println(s"\n‚ö†Ô∏è –û—à–∏–±–∫–∏ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–æ–≤ (${errorList.size}):")
  errorList.take(10).foreach { case (path, error) =>
    println(s"  - $path: $error")
  }
  if (errorList.size > 10) {
    println(s"  ... –∏ –µ—â–µ ${errorList.size - 10} –æ—à–∏–±–æ–∫")
  }
}
```

**–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤—ã–≤–æ–¥–∞**: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º 10 –æ—à–∏–±–æ–∫, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Ö–ª–∞–º–ª—è—Ç—å –∫–æ–Ω—Å–æ–ª—å.

```scala
resultMap.toMap
```

–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º `TrieMap` –≤ –æ–±—ã—á–Ω—ã–π immutable `Map` –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞.

***

## –ê–ª–≥–æ—Ä–∏—Ç–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π

### compareStates

```scala
def compareStates(oldState: Map[String, FileInfo], newState: Map[String, FileInfo]): Seq[FileState] = {
  val oldPaths = oldState.keySet
  val newPaths = newState.keySet

  val oldHashToPath = oldState.groupBy(_._2.hash).map { case (hash, entries) =>
    hash -> entries.keys.toSet
  }
  val newHashToPath = newState.groupBy(_._2.hash).map { case (hash, entries) =>
    hash -> entries.keys.toSet
  }

  val renames = scala.collection.mutable.Set[(String, String, Int)]()
  val processedOld = scala.collection.mutable.Set[String]()
  val processedNew = scala.collection.mutable.Set[String]()

  oldState.foreach { case (oldPath, oldInfo) =>
    if (!newPaths.contains(oldPath) && oldInfo.hash != 0) {
      newHashToPath.get(oldInfo.hash).foreach { paths =>
        paths.foreach { newPath =>
          if (!oldPaths.contains(newPath) && !processedNew.contains(newPath)) {
            renames += ((oldPath, newPath, oldInfo.hash))
            processedOld += oldPath
            processedNew += newPath
          }
        }
      }
    }
  }

  val allPaths = (oldPaths ++ newPaths).toSeq.sorted

  allPaths.flatMap { path =>
    if (processedOld.contains(path) || processedNew.contains(path)) {
      None
    } else {
      (oldState.get(path), newState.get(path)) match {
        case (Some(old), Some(neu)) if old.hash == neu.hash =>
          Some(Unchanged(path, old.hash))
        case (Some(old), Some(neu)) =>
          Some(Modified(path, old.hash, neu.hash))
        case (Some(old), None) =>
          Some(Deleted(path, old.hash))
        case (None, Some(neu)) =>
          Some(Added(path, neu.hash))
        case _ =>
          Some(ErrorFile(path, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ"))
      }
    }
  } ++ renames.map { case (oldPath, newPath, hash) =>
    Renamed(oldPath, newPath, hash)
  }
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–≤—É—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π.[^6][^10]

**–≠—Ç–æ —Å–∞–º–∞—è —Å–ª–æ–∂–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ –∫–æ–¥–µ. –†–∞–∑–±–µ—Ä–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ:**

### –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö

```scala
val oldPaths = oldState.keySet
val newPaths = newState.keySet
```

–ú–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤—Å–µ—Ö –ø—É—Ç–µ–π –≤ —Å—Ç–∞—Ä–æ–º –∏ –Ω–æ–≤–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏. `Set` –¥–ª—è O(1) –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏.

### –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–æ–≤

```scala
val oldHashToPath = oldState.groupBy(_._2.hash).map { case (hash, entries) =>
  hash -> entries.keys.toSet
}
```

**–°–ª–æ–∂–Ω–∞—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è, —Ä–∞–∑–±–µ—Ä–µ–º –ø–æ —à–∞–≥–∞–º**:

1. `oldState.groupBy(_._2.hash)`:
    - `oldState` —ç—Ç–æ `Map[String, FileInfo]`
    - –ò—Ç–µ—Ä–∏—Ä—É–µ–º –ø–æ –ø–∞—Ä–∞–º `(path, fileInfo)`
    - `_._2` –∏–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç tuple (FileInfo)
    - `.hash` –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ–ª–µ hash
    - `groupBy` –≥—Ä—É–ø–ø–∏—Ä—É–µ—Ç –ø–æ —Ö–µ—à—É: `Map[Int, Map[String, FileInfo]]`
2. `.map { case (hash, entries) => hash -> entries.keys.toSet }`:
    - `entries` —ç—Ç–æ `Map[String, FileInfo]` –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ö–µ—à–∞
    - `.keys` –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø—É—Ç–∏ (Set[String])
    - –†–µ–∑—É–ª—å—Ç–∞—Ç: `Map[Int, Set[String]]` ‚Äî –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ö–µ—à–∞ —Å–ø–∏—Å–æ–∫ –ø—É—Ç–µ–π

**–ü—Ä–∏–º–µ—Ä**:

```
oldState = {
  "file1.txt" -> FileInfo(hash=123, ...),
  "file2.txt" -> FileInfo(hash=456, ...),
  "file3.txt" -> FileInfo(hash=123, ...)
}

oldHashToPath = {
  123 -> Set("file1.txt", "file3.txt"),
  456 -> Set("file2.txt")
}
```

**–ó–∞—á–µ–º**: –ë—ã—Å—Ç—Ä–æ –Ω–∞–π—Ç–∏ –≤—Å–µ —Ñ–∞–π–ª—ã —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —Ö–µ—à–µ–º.

### –ê–ª–≥–æ—Ä–∏—Ç–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π

```scala
val renames = scala.collection.mutable.Set[(String, String, Int)]()
val processedOld = scala.collection.mutable.Set[String]()
val processedNew = scala.collection.mutable.Set[String]()
```

Mutable –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. Tuple `(String, String, Int)` = (—Å—Ç–∞—Ä—ã–π –ø—É—Ç—å, –Ω–æ–≤—ã–π –ø—É—Ç—å, —Ö–µ—à).

```scala
oldState.foreach { case (oldPath, oldInfo) =>
```

–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è.

```scala
if (!newPaths.contains(oldPath) && oldInfo.hash != 0) {
```

**–£—Å–ª–æ–≤–∏—è –¥–ª—è –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è**:

1. `!newPaths.contains(oldPath)` ‚Äî —Ñ–∞–π–ª –∏—Å—á–µ–∑ —Å–æ —Å–≤–æ–µ–≥–æ —Å—Ç–∞—Ä–æ–≥–æ –º–µ—Å—Ç–∞
2. `oldInfo.hash != 0` ‚Äî —ç—Ç–æ –Ω–µ –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª (–¥–ª—è –ø—É—Å—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è)
```scala
newHashToPath.get(oldInfo.hash).foreach { paths =>
```

**–ò—â–µ–º —Ñ–∞–π–ª —Å —Ç–∞–∫–∏–º –∂–µ —Ö–µ—à–µ–º –≤ –Ω–æ–≤–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏**:

- `newHashToPath.get(hash)` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `Option[Set[String]]`
- `.foreach` –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞—à–ª–∏ (`Some`)
- `paths` ‚Äî –º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–æ–≤—ã—Ö –ø—É—Ç–µ–π —Å —Ç–∞–∫–∏–º —Ö–µ—à–µ–º

```scala
paths.foreach { newPath =>
  if (!oldPaths.contains(newPath) && !processedNew.contains(newPath)) {
    renames += ((oldPath, newPath, oldInfo.hash))
    processedOld += oldPath
    processedNew += newPath
  }
}
```

**–§–∏–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏**:

- `!oldPaths.contains(newPath)` ‚Äî —ç—Ç–æ—Ç –ø—É—Ç—å –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω (–µ–≥–æ –Ω–µ –±—ã–ª–æ —Ä–∞–Ω—å—à–µ)
- `!processedNew.contains(newPath)` ‚Äî —ç—Ç–æ—Ç –Ω–æ–≤—ã–π –ø—É—Ç—å –µ—â–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è

**–ï—Å–ª–∏ –≤—Å–µ —É—Å–ª–æ–≤–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω—ã** ‚Äî —ç—Ç–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ!

- –î–æ–±–∞–≤–ª—è–µ–º –≤ `renames`
- –ü–æ–º–µ—á–∞–µ–º –æ–±–∞ –ø—É—Ç–∏ –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ

**–ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã –∞–ª–≥–æ—Ä–∏—Ç–º–∞**:

```
–°—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:
  "dir/old_name.txt" -> hash=999

–ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:
  "dir/new_name.txt" -> hash=999

–ê–ª–≥–æ—Ä–∏—Ç–º:
1. –†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º "dir/old_name.txt"
2. –ï–≥–æ –Ω–µ—Ç –≤ newPaths ‚úì
3. hash != 0 ‚úì
4. –ò—â–µ–º hash=999 –≤ newHashToPath ‚Üí –Ω–∞—Ö–æ–¥–∏–º "dir/new_name.txt"
5. "dir/new_name.txt" –Ω–µ –±—ã–ª–æ –≤ oldPaths ‚úì
6. –ï—â–µ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ ‚úì
7. –ó–∞–∫–ª—é—á–µ–Ω–∏–µ: RENAMED("dir/old_name.txt", "dir/new_name.txt", 999)
```


### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π

```scala
val allPaths = (oldPaths ++ newPaths).toSeq.sorted
```

–û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –ø—É—Ç–∏ –∏–∑ –æ–±–æ–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º. `++` ‚Äî –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤ (–¥—É–±–ª–∏–∫–∞—Ç—ã —É–¥–∞–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏).

```scala
allPaths.flatMap { path =>
  if (processedOld.contains(path) || processedNew.contains(path)) {
    None
```

**–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã**: –ï—Å–ª–∏ –ø—É—Ç—å —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∫–∞–∫ —á–∞—Å—Ç—å –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º `None` (–±—É–¥–µ—Ç –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ `flatMap`).

```scala
(oldState.get(path), newState.get(path)) match {
```

**Tuple pattern matching**: –ü–æ–ª—É—á–∞–µ–º `Option[FileInfo]` –∏–∑ –æ–±–æ–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ–º –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏.

```scala
case (Some(old), Some(neu)) if old.hash == neu.hash =>
  Some(Unchanged(path, old.hash))
```

–§–∞–π–ª –µ—Å—Ç—å –≤ –æ–±–æ–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è—Ö, —Ö–µ—à–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç ‚Üí **–Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è**.

```scala
case (Some(old), Some(neu)) =>
  Some(Modified(path, old.hash, neu.hash))
```

–§–∞–π–ª –µ—Å—Ç—å –≤ –æ–±–æ–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è—Ö, —Ö–µ—à–∏ —Ä–∞–∑–Ω—ã–µ ‚Üí **–∏–∑–º–µ–Ω–µ–Ω**.

```scala
case (Some(old), None) =>
  Some(Deleted(path, old.hash))
```

–§–∞–π–ª –±—ã–ª, —Ç–µ–ø–µ—Ä—å –µ–≥–æ –Ω–µ—Ç ‚Üí **—É–¥–∞–ª–µ–Ω**.

```scala
case (None, Some(neu)) =>
  Some(Added(path, neu.hash))
```

–§–∞–π–ª–∞ –Ω–µ –±—ã–ª–æ, —Ç–µ–ø–µ—Ä—å –µ—Å—Ç—å ‚Üí **–¥–æ–±–∞–≤–ª–µ–Ω**.

```scala
} ++ renames.map { case (oldPath, newPath, hash) =>
  Renamed(oldPath, newPath, hash)
}
```

**–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**: –ö —Å–ø–∏—Å–∫—É –æ–±—ã—á–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è.

### –ü–æ—á–µ–º—É –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

**–ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è**: –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ = –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –ø—É—Ç–∏ + –ø–æ—è–≤–ª–µ–Ω–∏–µ –¥—Ä—É–≥–æ–≥–æ –ø—É—Ç–∏ —Å **—Ç–µ–º –∂–µ —Ö–µ—à–æ–º**.

**–ì—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏**:

1. **–§–∞–π–ª —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω**: –û–±–∞ –ø—É—Ç–∏ –æ—Å—Ç–∞—é—Ç—Å—è ‚Üí –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—Å—è –∫–∞–∫ Unchanged + Added
2. **–î–≤–∞ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω—ã –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞**: `processedNew` –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π
3. **–§–∞–π–ª –∏–∑–º–µ–Ω–µ–Ω –∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω**: –•–µ—à–∏ –Ω–µ —Å–æ–≤–ø–∞–¥—É—Ç ‚Üí –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—Å—è –∫–∞–∫ Deleted + Added (–Ω–µ –∫–∞–∫ Renamed)
4. **–ü—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã**: –ü—Ä–æ–ø—É—Å–∫–∞—é—Ç—Å—è (`hash != 0`), —Ç–∞–∫ –∫–∞–∫ –≤—Å–µ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ö–µ—à

***

## –ì–µ–Ω–µ—Ä–∞—Ü–∏—è HTML-–æ—Ç—á–µ—Ç–æ–≤

### DirectoryNode

```scala
case class DirectoryNode(name: String, files: List[FileState], subdirs: Map[String, DirectoryNode])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –î—Ä–µ–≤–æ–≤–∏–¥–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –≤ –æ—Ç—á–µ—Ç–µ.

**–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞**: `subdirs` —Å–æ–¥–µ—Ä–∂–∏—Ç –¥—Ä—É–≥–∏–µ `DirectoryNode`, —Ñ–æ—Ä–º–∏—Ä—É—è –¥–µ—Ä–µ–≤–æ.

### buildDirectoryTree

```scala
def buildDirectoryTree(results: Seq[FileState]): DirectoryNode = {
  def insertIntoTree(node: DirectoryNode, pathParts: List[String], state: FileState): DirectoryNode = {
    pathParts match {
      case Nil => node
      case fileName :: Nil =>
        node.copy(files = state :: node.files)
      case dirName :: rest =>
        val subdir = node.subdirs.getOrElse(dirName, DirectoryNode(dirName, List.empty, Map.empty))
        val updatedSubdir = insertIntoTree(subdir, rest, state)
        node.copy(subdirs = node.subdirs + (dirName -> updatedSubdir))
    }
  }

  val root = DirectoryNode("root", List.empty, Map.empty)
  results.foldLeft(root) { (tree, state) =>
    val path = state match {
      case Unchanged(p, _) => p
      case Modified(p, _, _) => p
      case Deleted(p, _) => p
      case Added(p, _) => p
      case Renamed(_, newP, _) => newP
      case ErrorFile(p, _) => p
      case EmptyFile(p) => p
    }
    val pathParts = path.split('/').toList
    insertIntoTree(tree, pathParts, state)
  }
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –∏–∑ –ø–ª–æ—Å–∫–æ–≥–æ —Å–ø–∏—Å–∫–∞ –ø—É—Ç–µ–π.

**–ê–ª–≥–æ—Ä–∏—Ç–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–π –≤—Å—Ç–∞–≤–∫–∏**:

```scala
def insertIntoTree(node: DirectoryNode, pathParts: List[String], state: FileState): DirectoryNode = {
```

–§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª, —á–∞—Å—Ç–∏ –ø—É—Ç–∏ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ–∞–π–ª–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —É–∑–µ–ª.

```scala
pathParts match {
  case Nil => node
```

–ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: –ø—É—Ç—å –∏—Å—á–µ—Ä–ø–∞–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É–∑–µ–ª –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.

```scala
case fileName :: Nil =>
  node.copy(files = state :: node.files)
```

**–ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –ø—É—Ç–∏ (—Ñ–∞–π–ª)**:

- `fileName :: Nil` ‚Äî —Å–ø–∏—Å–æ–∫ –∏–∑ –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
- `node.copy(...)` —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —É–∑–µ–ª —Å –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º –ø–æ–ª–µ–º `files`
- `state :: node.files` –¥–æ–±–∞–≤–ª—è–µ—Ç state –≤ –Ω–∞—á–∞–ª–æ —Å–ø–∏—Å–∫–∞ (cons –æ–ø–µ—Ä–∞—Ç–æ—Ä)

**Immutability**: `copy` —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç, –Ω–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π. –≠—Ç–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ Scala.

```scala
case dirName :: rest =>
  val subdir = node.subdirs.getOrElse(dirName, DirectoryNode(dirName, List.empty, Map.empty))
  val updatedSubdir = insertIntoTree(subdir, rest, state)
  node.copy(subdirs = node.subdirs + (dirName -> updatedSubdir))
```

**–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Å–ª—É—á–∞–π (–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è)**:

1. `dirName :: rest` ‚Äî –ø—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∏–º–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ –µ—Å—Ç—å –µ—â–µ —á–∞—Å—Ç–∏
2. `getOrElse` ‚Äî –ø–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
3. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –æ—Å—Ç–∞–≤—à–∏–π—Å—è –ø—É—Ç—å (`rest`)
4. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π Map –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π

**–ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã**:

```
–í—Å—Ç–∞–≤–∫–∞ "dir1/dir2/file.txt":

1. insertIntoTree(root, ["dir1", "dir2", "file.txt"], state)
   - –°–æ–∑–¥–∞–µ–º/–Ω–∞—Ö–æ–¥–∏–º dir1
   - –†–µ–∫—É—Ä—Å–∏—è: insertIntoTree(dir1_node, ["dir2", "file.txt"], state)

2. insertIntoTree(dir1_node, ["dir2", "file.txt"], state)
   - –°–æ–∑–¥–∞–µ–º/–Ω–∞—Ö–æ–¥–∏–º dir2
   - –†–µ–∫—É—Ä—Å–∏—è: insertIntoTree(dir2_node, ["file.txt"], state)

3. insertIntoTree(dir2_node, ["file.txt"], state)
   - –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç ‚Üí –¥–æ–±–∞–≤–ª—è–µ–º –≤ files
   - –í–æ–∑–≤—Ä–∞—â–∞–µ–º dir2_node.copy(files = state :: dir2_node.files)

4. –†–∞–∑–º–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∫—É—Ä—Å–∏—é, –æ–±–Ω–æ–≤–ª—è—è —É–∑–ª—ã —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
```


### foldLeft

```scala
val root = DirectoryNode("root", List.empty, Map.empty)
results.foldLeft(root) { (tree, state) =>
```

**`foldLeft`** ‚Äî –ª–µ–≤–æ—Å—Ç–æ—Ä–æ–Ω–Ω—è—è —Å–≤–µ—Ä—Ç–∫–∞ (fold):

- –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: `root` (–ø—É—Å—Ç–æ–µ –¥–µ—Ä–µ–≤–æ)
- –§—É–Ω–∫—Ü–∏—è: `(tree, state) => insertIntoTree(tree, ...)`
- –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É `results` –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
- –ê–∫–∫—É–º—É–ª—è—Ç–æ—Ä `tree` –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ —Å–ª–µ–¥—É—é—â—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é

**–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è**:

```
results = [state1, state2, state3]

tree0 = root
tree1 = insertIntoTree(tree0, state1)
tree2 = insertIntoTree(tree1, state2)
tree3 = insertIntoTree(tree2, state3)
—Ä–µ–∑—É–ª—å—Ç–∞—Ç = tree3
```


### renderDirectoryTree

```scala
def renderDirectoryTree(node: DirectoryNode, level: Int = 0): String = {
  val indent = "&nbsp;&nbsp;&nbsp;&nbsp;" * level
  val dirHeader = if (level > 0) {
    s"""<div style="margin-top: 10px; font-weight: bold; color: #333;">$indentüìÅ ${node.name}</div>"""
  } else {
    ""
  }

  val filesHtml = node.files.sortBy { ... }.map { state =>
    val content = state match {
      case Renamed(oldPath, newPath, _) =>
        val oldFileName = oldPath.split('/').last
        val newFileName = newPath.split('/').last
        s"$indent&nbsp;&nbsp;&nbsp;&nbsp;‚Üª –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: $oldFileName ‚Üí $newFileName".withClass("renamed").colorize("purple")
      // ... –¥—Ä—É–≥–∏–µ —Å–ª—É—á–∞–∏
    }
    content.wrapTag("div")
  }.mkString("\n")

  val subdirsHtml = node.subdirs.toSeq.sortBy(_._1).map { case (_, subdir) =>
    renderDirectoryTree(subdir, level + 1)
  }.mkString("\n")

  dirHeader + filesHtml + subdirsHtml
}
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ –≤ HTML.

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞**:

1. `indent` ‚Äî HTML –æ—Ç—Å—Ç—É–ø—ã (`&nbsp;` = non-breaking space)
2. `dirHeader` ‚Äî –∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –¥–ª—è –∫–æ—Ä–Ω—è)
3. `filesHtml` ‚Äî —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
4. `subdirsHtml` ‚Äî —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏

**–î–ª—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤**:

```scala
case Renamed(oldPath, newPath, _) =>
  val oldFileName = oldPath.split('/').last
  val newFileName = newPath.split('/').last
  s"$indent&nbsp;&nbsp;&nbsp;&nbsp;‚Üª –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: $oldFileName ‚Üí $newFileName"
```

**–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–º–µ–Ω**:

- `split('/')` —Ä–∞–∑–±–∏–≤–∞–µ—Ç –ø—É—Ç—å: `"dir/subdir/file.txt"` ‚Üí `["dir", "subdir", "file.txt"]`
- `.last` –±–µ—Ä–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç: `"file.txt"`
- –û—Ç–æ–±—Ä–∞–∂–∞–µ–º: `old_name.txt ‚Üí new_name.txt`


### Implicit class HtmlOps

```scala
implicit class HtmlOps(s: String) {
  def wrapTag(tag: String): String = s"<$tag>$s</$tag>"
  def withClass(className: String): String = s"""<span class="$className">$s</span>"""
  def colorize(color: String): String = s"""<span style="color: $color;">$s</span>"""
}
```

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Scala**: Implicit classes –¥–æ–±–∞–≤–ª—è—é—Ç –º–µ—Ç–æ–¥—ã –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º —Ç–∏–ø–∞–º.

**–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç**:

```scala
"—Ç–µ–∫—Å—Ç".wrapTag("div")
```

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤–∏–¥–∏—Ç, —á—Ç–æ —É `String` –Ω–µ—Ç –º–µ—Ç–æ–¥–∞ `wrapTag`, –Ω–∞—Ö–æ–¥–∏—Ç implicit –∫–ª–∞—Å—Å `HtmlOps` –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤:

```scala
new HtmlOps("—Ç–µ–∫—Å—Ç").wrapTag("div")
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç**: `"<div>—Ç–µ–∫—Å—Ç</div>"`

**Chain calling**:

```scala
"—Ñ–∞–π–ª".withClass("renamed").colorize("purple")
// ‚Üí "<span style=\"color: purple;\"><span class=\"renamed\">—Ñ–∞–π–ª</span></span>"
```


***

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ Scala

### 1. Type Safety (–¢–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)

```scala
sealed trait FileState
case class Modified(path: String, oldHash: Int, newHash: Int) extends FileState
```

**Exhaustive matching**:

```scala
state match {
  case Unchanged(p, _) => ...
  case Modified(p, _, _) => ...
  // –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏—Ç, –µ—Å–ª–∏ –∑–∞–±—ã–ª–∏ Deleted, Added –∏ —Ç.–¥.
}
```

**–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ null**: –í–º–µ—Å—Ç–æ `null` –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è `Option[T]`, `Either[L, R]`, –ø—É—Å—Ç—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏.

### 2. Immutability (–ù–µ–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å)

```scala
case class FileInfo(path: String, hash: Int, size: Long, lastModified: String)
```

**–í—Å–µ –ø–æ–ª—è `val` –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é** (–≤ case class). –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è. –ò–∑–º–µ–Ω–µ–Ω–∏—è –¥–µ–ª–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ `copy`:

```scala
val info = FileInfo("file.txt", 123, 1000, "2025-01-01")
val updated = info.copy(hash = 456)  // –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
```


### 3. Pattern Matching

```scala
calculateHash(file) match {
  case FileSuccess(hash) => ...
  case FileError(msg) => ...
}
```

**–ú–æ—â–Ω–µ–µ switch –∏–∑ Java/C**:

- –†–∞–±–æ—Ç–∞–µ—Ç —Å —Ç–∏–ø–∞–º–∏, –Ω–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏–º–∏—Ç–∏–≤–∞–º–∏
- –î–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏—è (destructuring): `case Modified(path, old, new) => ...`
- Guard clauses: `case Some(x) if x > 10 => ...`
- Exhaustiveness checking


### 4. For-Comprehensions –∏ Monads

```scala
sealed trait FileOperation[+A] {
  def map[B](f: A => B): FileOperation[B]
  def flatMap[B](f: A => FileOperation[B]): FileOperation[B]
}
```

**–ú–æ–Ω–∞–¥–∞** ‚Äî –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π. –ù–∞—à `FileOperation` ‚Äî –ø—Ä–æ—Å—Ç–∞—è –º–æ–Ω–∞–¥–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.

**–ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å for-comprehension**:

```scala
for {
  hash <- calculateHash(file)
  info <- processHash(hash)
  result <- saveInfo(info)
} yield result
```

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤ `flatMap` –∏ `map`.

### 5. Higher-Order Functions

```scala
files.flatMap { path => ... }
results.foldLeft(root) { (tree, state) => ... }
```

**–§—É–Ω–∫—Ü–∏–∏ ‚Äî –æ–±—ä–µ–∫—Ç—ã –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞**:

- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
- –í–æ–∑–≤—Ä–∞—â–∞—Ç—å –∏–∑ —Ñ—É–Ω–∫—Ü–∏–π
- –•—Ä–∞–Ω–∏—Ç—å –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö


### 6. Implicit Conversions

```scala
import scala.jdk.CollectionConverters._
val scalaList = javaIterator.asScala.toList
```

**Java Interop**: Scala –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç implicit –∫–æ–Ω–≤–µ—Ä—Å–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Java –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏, –Ω–æ –∏—Ö –Ω—É–∂–Ω–æ —è–≤–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å (–≤ Scala 2.13+).

### 7. String Interpolation

```scala
s"–ü—Ä–æ–≥—Ä–µ—Å—Å: $processed/$totalFilesCount ($progress%)"
```

**–¢—Ä–∏ –≤–∏–¥–∞**:

- `s"..."` ‚Äî –ø—Ä–æ—Å—Ç–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
- `f"$value%.2f"` ‚Äî —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
- `raw"..."` ‚Äî –±–µ–∑ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è `\n` –∏ —Ç.–¥.


### 8. Option Type

```scala
val maybeValue: Option[Int] = Some(42)
val nothing: Option[Int] = None

maybeValue.foreach(v => println(v))  // –≤—ã–≤–µ–¥–µ—Ç 42
nothing.foreach(v => println(v))      // –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–≤–µ–¥–µ—Ç
```

**–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–º–µ–Ω–∞ null**: –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è.

### 9. Collections API

**–ë–æ–≥–∞—Ç—ã–π API**:

- `map`, `flatMap`, `filter`, `fold`, `reduce`, `groupBy`, `partition`
- Lazy collections: `Iterator`, `LazyList` (Stream –≤ Scala 2.12)
- Parallel collections: `par` (–≤ –¥–∞–Ω–Ω–æ–º –∫–æ–¥–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)

```scala
List(1, 2, 3).map(_ * 2).filter(_ > 3)  // List(4, 6)
```


### 10. Value Classes

```scala
class BitStreamProcessor(val buffer: ByteBuffer) extends AnyVal
```

**Zero-cost abstraction**: –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä —É–¥–∞–ª—è–µ—Ç –æ–±–µ—Ä—Ç–∫—É –≤ runtime, –≤—ã–∑—ã–≤–∞—è –º–µ—Ç–æ–¥—ã –Ω–∞–ø—Ä—è–º—É—é. –ù–µ—Ç overhead.

***

## –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### 1. –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è I/O

```scala
val buffer = ByteBuffer.allocate(math.min(size.toInt, 1024 * 1024))
```

**1MB –±—É—Ñ–µ—Ä** –±–∞–ª–∞–Ω—Å–∏—Ä—É–µ—Ç:

- –ü–∞–º—è—Ç—å (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –≤–µ—Å—å —Ñ–∞–π–ª)
- –°–∫–æ—Ä–æ—Å—Ç—å (–º–µ–Ω—å—à–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤)


### 2. XOR –≤–º–µ—Å—Ç–æ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö —Ö–µ—à–µ–π

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:

- –í 10-100 —Ä–∞–∑ –±—ã—Å—Ç—Ä–µ–µ SHA-256[^4][^2]
- –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
- –ù–∏–∑–∫–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –∫–æ–ª–ª–∏–∑–∏–π –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:

- –ù–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∏–π
- –õ–µ–≥–∫–æ —Å–æ–∑–¥–∞—Ç—å –∫–æ–ª–ª–∏–∑–∏–∏ –ø—Ä–µ–¥–Ω–∞–º–µ—Ä–µ–Ω–Ω–æ
- –ù–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –∞—Ç–∞–∫


### 3. –û–±—Ä–∞—Ç–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π

```scala
val oldHashToPath = oldState.groupBy(_._2.hash)
```

**O(1) lookup** –≤–º–µ—Å—Ç–æ O(n) –ø–µ—Ä–µ–±–æ—Ä–∞. –î–ª—è 10000 —Ñ–∞–π–ª–æ–≤ —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ.

### 4. –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏

```scala
val relativePath = root.relativize(file).toString
```

**–ú–µ–Ω—å—à–µ –¥–∞–Ω–Ω—ã—Ö** –≤ JSON, –±—ã—Å—Ç—Ä–µ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫.

***

## –í–æ–∑–º–æ–∂–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

### 1. –ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–∞—Ü–∏—è

```scala
files.par.foreach { file =>
  calculateHash(file)
}
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `.par` –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ –º–Ω–æ–≥–æ—è–¥–µ—Ä–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö.

### 2. –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ

–•–µ—à–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã (–ø–æ `lastModified`):

```scala
if (oldInfo.lastModified == newInfo.lastModified) {
  // –§–∞–π–ª –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π —Ö–µ—à
}
```


### 3. Streaming –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤

–í–º–µ—Å—Ç–æ –∑–∞–≥—Ä—É–∑–∫–∏ 1MB –±–ª–æ–∫–æ–≤, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å streaming:

```scala
Source.fromFile(file).getLines().foreach { line => ... }
```


### 4. –ö–æ–º–ø—Ä–µ—Å—Å–∏—è JSON

–°–∂–∏–º–∞—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö —Ö–µ—à–µ–π gzip'–æ–º –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞.

### 5. –ë–æ–ª–µ–µ —Å—Ç–æ–π–∫–∏–π —Ö–µ—à

–î–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–π –∑–∞–º–µ–Ω–∏—Ç—å XOR –Ω–∞ SHA-256 –∏–ª–∏ Blake3.[^5][^2][^4]

***

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –∫–ª—é—á–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ Scala:

- **Immutability** ‚Äî –≤—Å–µ data structures –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã
- **Type safety** ‚Äî sealed traits –∏ exhaustive matching
- **Higher-order functions** ‚Äî flatMap, foldLeft, groupBy
- **Pattern matching** ‚Äî –¥–ª—è control flow
- **Monadic error handling** ‚Äî FileOperation –≤–º–µ—Å—Ç–æ exceptions

–ê–ª–≥–æ—Ä–∏—Ç–º—ã –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è:

- **–°–∫–æ—Ä–æ—Å—Ç–∏** ‚Äî XOR —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ, –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è, –æ–±—Ä–∞—Ç–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã
- **–ü–∞–º—è—Ç–∏** ‚Äî streaming file reading, –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –≤ RAM
- **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç–∏** ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –±–µ–∑ –ø–∞–¥–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã

–ö–æ–¥ –Ω–∞–ø–∏—Å–∞–Ω –≤ —á–∏—Å—Ç–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º —Å—Ç–∏–ª–µ –±–µ–∑ –º—É—Ç–∞—Ü–∏–π (–∫—Ä–æ–º–µ –ª–æ–∫–∞–ª—å–Ω—ã—Ö `var` –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏) –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–µ–≥–∫–æ —Ä–∞—Å—à–∏—Ä–µ–Ω –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏, –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –¥–µ—Ç–µ–∫—Ü–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π –∏–ª–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤ CI/CD pipeline –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤.[^10][^1]
<span style="display:none">[^3][^7][^8]</span>

<div align="center">‚ÅÇ</div>

[^1]: https://stackoverflow.com/questions/37307097/compute-file-content-hash-with-scala

[^2]: https://mojoauth.com/hashing/sha-256-in-scala/

[^3]: https://mojoauth.com/hashing/dhash-in-scala/

[^4]: https://compile7.org/hashing/how-to-use-sha-512-in-scala/

[^5]: https://github.com/kcrypt/scala-sha

[^6]: https://compile7.org/hashing/how-to-use-sha-384-in-scala/

[^7]: https://contributors.scala-lang.org/t/equality-and-hash-typeclasses/1735

[^8]: https://rosenville.com/scala-md5-sha-string-hashing/

[^9]: https://users.scala-lang.org/t/help-writing-equals-and-a-compatible-hashcode/5721

[^10]: https://www.reddit.com/r/learnprogramming/comments/hxo0no/best_hash_algorithm_for_comparing_files_w/

